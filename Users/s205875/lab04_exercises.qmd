---
title: "lab04_exercises.qmd"
format: html
editor: visual
---

# Load libraries

```{r}
library("tidyverse")

#setting the librady to "here" (where you are in the directory)
library("here")
library(dplyr) 
library(ggplot2)


```

# A few initial questions

First, in a new chunk, run `tibble(x = c(4, 3, 5, 1, 2))`, so you understand what it does, then - Discuss in your group, what is the output of, remember first talk, then check understanding by running code:

This creates a tibble (a modern data frame) with one column `x`. each row has a number in the order of 4-3-5-1-2

```{r}
tibble(x = c(4, 3, 5, 1, 2))
```

## **Q1: `tibble(x = c(4, 3, 5, 1, 2)) |> filter(x > 2)`?**

This filter all numbers in the tibble that is above 2

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> filter(x > 2)
```

## **Q2: `tibble(x = c(4, 3, 5, 1, 2)) |> arrange(x)`?**

This arranges (sorts) the numbers so they go from 1-5. Sorts in ascending order.

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> arrange(x)
```

## **Q3: `tibble(x = c(4, 3, 5, 1, 2)) |> arrange(desc(x))`?**

This arranges (sorts) the numbers so they go from 5-1. Sorts in descending order.

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> arrange(desc(x))
```

## **Q4: `tibble(x = c(4, 3, 5, 1, 2)) |> arrange(desc(desc(x)))`?**

This arranges (sorts) the numbers so they go from 1-5.

Double negation → same as arranging ascending.

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> arrange(desc(desc(x)))
```

## **Q5: `tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(x)`?**

This makes another column with x and y numbers Then it selects the x column and only display that. Keeps only column x.

```{r}
tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(x)
```

## **Q6: `tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(y)`?**

This makes another column with x and y numbers Then it selects the y column and only display that. Keeps only column y.

```{r}
tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(y)
```

## **Q7: `tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(-x)`?**

Drops column `x`, so only `y` remains

```{r}
tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(-x)
```

## **Q8: `tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(-x, -y)`?**

Drops both columns → tibble with **0 columns and 5 rows**.

```{r}
tibble(x = c(4, 3, 5, 1, 2), y = c(2, 4, 3, 5, 1)) |> select(-x, -y)
```

## **Q9: `tibble(x = c(4, 3, 5, 1, 2)) |> mutate(x_dbl = 2*x)`?**

Adds a new column `x_dbl`. This column is the double value of the x column

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> mutate(x_dbl = 2*x)
```

## **Q10: `tibble(x = c(4, 3, 5, 1, 2)) |> mutate(x_dbl = 2 * x, x_qdr = 2*x_dbl)`?**

Adds both `x_dbl` and `x_qdr`. this is times two and times four of the x column

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> mutate(x_dbl = 2 * x, x_qdr = 2*x_dbl)
```

## **Q11: `tibble(x = c(4, 3, 5, 1, 2)) |> summarise(x_mu = mean(x))`?**

Computes mean of `x`. `(4+3+5+1+2)/5 = 15/5 = 3`.

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> summarise(x_mu = mean(x))
```

## **Q12: `tibble(x = c(4, 3, 5, 1, 2)) |> summarise(x_max = max(x))`?**

FInd the largest value int the tibble = 5

```{r}
tibble(x = c(4, 3, 5, 1, 2)) |> summarise(x_max = max(x))
```

## **Q13: `tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, NA, 5, 1, 2)) |> group_by(lbl) |> summarise(x_mu = mean(x), x_max = max(x))`?**

Make a grouping column (lbl) that has group A, B and C. Then find the mean and the max number in each group

```{r}
tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, NA, 5, 1, 2)) |> group_by(lbl) |> summarise(x_mu = mean(x), x_max = max(x))
```

## **Q14: `tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, 3, 5, 1, 2)) |> group_by(lbl) |> summarise(n = n())`?**

Counts rows per group (A, B, C)

```{r}
tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, 3, 5, 1, 2)) |> group_by(lbl) |> summarise(n = n())
```

## **Q15: `tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, 3, 5, 1, 2)) |> count(lbl)`?**

Shorthand for the same as above.

```{r}
tibble(lbl = c("A", "A", "B", "B", "C"), x = c(4, 3, 5, 1, 2)) |> count(lbl)
```

# Load data

```{r}

#| echo: true
#| eval: false 

diabetes_data <- read_csv(file = here("data/diabetes.csv"))
diabetes_data
```

```{r}

#| echo: true
#| eval: false 


# Create the data directory programmatically
dir.create(path = "data")

# Retrieve the data directly
diabetes_data <- read_csv(file = "https://hbiostat.org/data/repo/diabetes.csv")

# Write the data to disk
write_csv(x = diabetes_data,
          file = "data/diabetes.csv")
```

# Work with the diabetes data set

The data consist of 19 variables on 403 subjects from 1046 subjects who were interviewed in a study to understand the prevalence of obesity, diabetes, and other cardiovascular risk factors in central Virginia for African Americans. According to Dr John Hong, Diabetes Mellitus Type II (adult onset diabetes) is associated most strongly with obesity. The waist/hip ratio may be a predictor in diabetes and heart disease. DM II is also agssociated with hypertension - they may both be part of "Syndrome X". The 403 subjects were the ones who were actually screened for diabetes. Glycosolated hemoglobin \> 7.0 is usually taken as a positive diagnosis of diabetes.

**Viewing the dataset:**

```{r}
view(diabetes_data)
```

## **Q1: How many observations and how many variables?**

The dataset has 403 observations and 19 variables

```{r}
# Dimensions: (rows, columns)
dim(diabetes_data)
```

## **Q2: Is this a tidy data set? Which three rules must be satisfied?**

**Rules for tidy data (Hadley Wickham’s principles):**

Each variable in its own column.

Each observation in its own row.

Each type of observational unit in one table.

## **Q3: When you run the chunk, then underneath each column name is stated `<chr>` and `<dbl>` what is that?**

When you see <chr> or <dbl> under the column names in R output:

<chr> = character data type (strings, text).

<dbl> = double (numeric values stored as double-precision floating point).

```{r}
library(tibble)
as_tibble(diabetes_data)
```

This will show a tibble where under each column name you’ll see:

<chr> = character (text)

<dbl> = double (numeric values, decimals)

<int> = integer

## **T1: Change the `height`, `weight`, `waist` and `hip` from the imperial system (inches/pounds) to the metric system (cm/kg), rounding to 1 decimal**

Height, Waist, Hip: inches → centimeters (cm = inch \* 2.54)

Weight: pounds → kilograms (kg = lb \* 0.45359237)

```{r}
diabetes_data <- diabetes_data %>%
  mutate(
    height = round(height * 2.54, 1),   # inches → cm
    weight = round(weight * 0.45359237, 1), # lbs → kg
    waist  = round(waist * 2.54, 1),    # inches → cm
    hip    = round(hip * 2.54, 1)       # inches → cm
  )
```

Checking the first few rows in the new dataset

```{r}
head(diabetes_data %>% select(height, weight, waist, hip))
```

Let us try to take a closer look at various subsets of the data. For the following questions, “How many …” refers to the number of rows in the subset of the data you create:

## **Q4: How many weigh less than 100kg?**

getting the dataset, filtering for weights less than 100 kg, then counting the number of observations

```{r}

diabetes_data %>%
  filter(weight < 100) %>%
  summarise(n = n())
```

There are 349 people that weight less than 100 kg

## **Q5: How many weigh more than 100kg?**

Getting the dataset, filtering for weights above than 100 kg, then counting the number of observations

```{r}
diabetes_data %>%
  filter(weight > 100) %>%
  summarise(n = n())
```

There are 53 people that weight more than 100 kg

## **Q6: How many weigh more than 100kg and are less than 1.6m tall?**

filtering for both weight and height

```{r}
diabetes_data %>%
  filter(weight > 100) %>%
  filter(height < 160) %>%
  summarise(n = n())
```

There are 2 people that weigh more than 100 kg and are less than 160 cm tall.

## **Q7: How many women are taller than 1.8m?**

Filtering for both gender and height

```{r}
diabetes_data %>%
  filter(gender == "female") %>%
  filter( height > 180) %>%
  summarise(n = n())
```

There are 4 women that are taller than 180 cm

## **Q8: How many men are taller than 1.8m?**

Filtering for both gender and height

```{r}
diabetes_data %>%
  filter(gender == "male") %>%
  filter( height > 180) %>%
  summarise(n = n())
```

There are 51 men that are taller than 180 cm

## **Q9: How many women in Louisa are older than 30?**

Filtering for both gender, location and age

```{r}
diabetes_data %>%
  filter(gender == "female") %>%
  filter(location == "Louisa") %>%
  filter( age > 30) %>%
  summarise(n = n())
```

There are 95 women in Louisa that are older than 30

## **Q10: How many men in Buckingham are younger than 30 and taller than 1.9m?**

Filtering for both gender, location, age and height

```{r}
diabetes_data %>%
  filter(gender == "male") %>%
  filter(location == "Buckingham") %>%
  filter( age < 30) %>%
  filter(height > 190) %>%
  summarise(n = n())
```

There are 1 man in Buckingham that are younger than 30 and taller than 190 cm

## **T2: Make a scatter plot of `weight` versus `height` and colour by sex for inhabitants of Louisa above the age of 40**

filter for Louisa and people above 40, and then plotting the weight vs height and coloring by gender.

```{r}
diabetes_data %>%
  filter(location == "Louisa", age > 40) %>% #filtering for location and age
  
  #plotting the weight vs heigh colored by gender for inhabitants of Louisa above the age of 40
  ggplot(aes(x = height, y = weight, colour = gender)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(
    title = "Weight vs Height in Louisa (Age > 40)",
    x = "Height (cm)",
    y = "Weight (kg)",
    colour = "Sex"
  ) +
  theme_minimal()

```

## **T3: Make a box plot of height versus location stratified on sex for people above the age of 50**

Filter for people above 50 and plotting height vs location stratified on sex

```{r}
diabetes_data %>%
  filter(age > 50) %>% #filtering for age
  
  #plotting the height vs location stratified by gender for people above the age of 50
  ggplot(aes(x = location, y = height, fill = location)) +
  geom_boxplot(alpha = 0.7, show.legend = FALSE) +
  facet_wrap(~ gender) +
  labs(
    title = "Height vs Location (Age > 50), Stratified by Sex",
    x = "Location",
    y = "Height (cm)"
  ) +
  theme_minimal()
```

Sorting columns can aid in getting an overview of variable ranges (don’t use the `summary()` function yet for this one)

## **Q11: How old is the youngest person?**

```{r}
diabetes_data %>%
  arrange(age) %>%
  select(age) %>%
  head(1)
```

The youngest is 19 years old

could have done :

```{r}
diabetes_data %>%
  summarise(age = min(age))
```

## **Q12: How old is the oldest person?**

```{r}
diabetes_data %>%
  arrange(desc(age)) %>%
  select(age) %>%
  head(1)
```

The oldest is 92 years old

Could have done :

```{r}
diabetes_data %>%
  summarise(age = max(age))
```

## 

## **Q13: Of all the 20-year-olds, what is the height of the tallest?**

```{r}
diabetes_data %>%
  filter(age == 20) %>%
  select(age,height) %>%
  arrange(desc(height)) %>%
  head(1)
```

The tallest 20 year old is 182.9 cm

Could have done:

```{r}
diabetes_data %>%
  filter(age == 20) %>%
  summarise(height = max(height))
```

## **Q14: Of all the 20-year-olds, what is the height of the shortest?**

```{r}
diabetes_data %>%
  filter(age == 20) %>%
  select(age,height) %>%
  arrange(height) %>%
  head(1)
```

The lowest 20 year old is 147.3 cm

Could have done:

```{r}
diabetes_data %>%
  filter(age == 20) %>%
  summarise(height = min(height))
```

Choosing specific columns can be used to work with a subset of the data for a specific purpose

## **Q15: How many columns (variables) `starts_with` a “b”?**

```{r}
diabetes_data %>%
  select(starts_with("b")) %>%
  ncol()
```

4 columns starts with a b

## **Q16: How many columns (variables) `contains` the word “eight”?**

```{r}

diabetes_data %>%
  select(contains("eight")) %>%
  ncol()
```

2 columns contains the word "eight"

Creating new variables is an integral part of data manipulation

## **T4: Create a new variable, where you calculate the BMI**

The formula fro BMI is:

BMI = weight / heigh (m)\^2

Remeber to devide by 100 to get height in m for the BMI calculation

```{r}


diabetes_data %>%
  #Making a new column with BMI
  mutate(
    BMI = weight / ((height/100)^2)
  ) %>%
  
  #selecting the columns to display
  select(weight, height, BMI) %>%
  head()

```

## **T5: Create a `BMI_class` variable**

## 

```{r}
diabetes_data <- diabetes_data %>%
  # create BMI (convert units first)
  mutate(
    BMI = weight / ((height/100)^2),
    # classify BMI    
    BMI_class = case_when(
      BMI < 16.5 ~ "Severely underweight",
      BMI >= 16.5 & BMI < 18.5 ~ "Underweight",
      BMI >= 18.5 & BMI < 25   ~ "Normal weight",
      BMI >= 25   & BMI < 30   ~ "Overweight",
      BMI >= 30   & BMI < 35   ~ "Obesity class I",
      BMI >= 35   & BMI < 40   ~ "Obesity class II",
      BMI >= 40               ~ "Obesity class III"
    ),
    # convert to ordered factor for plotting
    BMI_class = factor(
      BMI_class,
      levels = c("Severely underweight", "Underweight", "Normal weight",
                 "Overweight", "Obesity class I", "Obesity class II",
                 "Obesity class III")
    )
  )

# Check first rows
diabetes_data %>% select(weight, height, BMI, BMI_class) %>% head()
```

## **T6: Create a box plot of `hdl` versus BMI_class**

x = BMI class

y = hdl

fill = BMI_class

```{r}

diabetes_data %>%
  ggplot(aes(x = BMI_class, y = hdl, fill = BMI_class)) +
  geom_boxplot(alpha = 0.7, show.legend = FALSE) +
  labs(
    title = "HDL by BMI classification",
    x = "BMI class",
    y = "HDL (mg/dL)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

## **Q17: What do you see?**

**General trend:**

HDL tends to decrease as BMI class increases.

The “Severely underweight” and “Underweight” groups have the highest HDL values, while the obesity classes tend to have lower HDL medians.

**Spread:**

The variability in HDL is quite large in some groups (e.g., Normal weight, Overweight).

There are outliers in nearly every BMI group.

**Pattern:**

The median HDL seems to move downward as BMI goes from Normal → Overweight → Obese.

This suggests that higher BMI is associated with lower HDL (which is a known cardiovascular risk factor).

**Missing values (NA):**

You also see a box for “NA” - that means some people had no BMI classification (probably missing height/weight values).

## **T7: Create a `BFP` (Body fat percentage) variable**

BFP= 1.39 x BMI + 0.16 x age − 10.34 x sex−9

sex = 0 for female

sex = 1 for male

```{r}
diabetes_data <- diabetes_data %>%
  mutate(
    #define 0 or 1 to a new sex_num variable to be used in the calculation
    sex_num = if_else(gender == "male", 1, 0),
    
    #using the formula to define a new variable
    BFP = 1.39 * BMI + 0.16 * age - 10.34 * sex_num - 9
  )
```

## **T8: Create a `WHR` (waist-to-hip ratio) variable**

```{r}
#making a new variable woth the wait-to-hip ratio 
diabetes_data <- diabetes_data %>%
  mutate(
    WHR = waist / hip
  )
```

checking it:

```{r}
diabetes_data %>%
  select(waist, hip, WHR) %>%
  head()
```

## **Q18: What correlates better with `BMI`: `WHR` or `BFP`?** GROUP ASSIGNMENT (Important, see: [how to](https://r4bds.github.io/assignments.html))

*Is there a certain plot-type, which can visualise if the relationship between two variables and give insights to if they are correlated? Can you perhaps use an `R` function to compute the “correlation coefficient”?. Do not use e.g. `ggpubr` or any other and-then-magic-happens package, use the knowledge you’ve gained so far)*

To determine the correlation with BMI visualization and comparison of correlation coefficients are used.

To visualize correlation between two numeric variables a scatter plot is used to visualize the BMI vs WHR and BMI vs BFP.

To further compare the correlation, the Pearson’s correlation coefficient is calculated.

### Scatter plot of BMI vs WHR and BMI vs BFP.

In the visualized scatter plots the following is used to determine the correlation

Strong positive correlation: Points form a tight upward-sloping line (higher x = higher y).

Weak/No correlation: Points are widely scattered with no clear line.

Negative correlation: Points slope downward (higher x = lower y).

```{r}
# Plot BMI vs WHR
ggplot(diabetes_data, aes(x = BMI, y = WHR)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, colour = "blue") +
  labs(title = "BMI vs WHR", x = "BMI", y = "Waist-to-Hip Ratio") +
  theme_minimal()

# Plot BMI vs BFP
ggplot(diabetes_data, aes(x = BMI, y = BFP)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, colour = "red") +
  labs(title = "BMI vs BFP", x = "BMI", y = "Body Fat Percentage") +
  theme_minimal()
```

As seen in the plot showing BMI vs WHR:

-   The points are widely scattered with no tight linear pattern.

-   The regression line is almost flat meanign that WHR changes only slightly as BMI increases.

-   This indicates a weak correlation between BMI and WHR.

As seen in the plot showing BMI vs BFP:

-   The points form a tight upward-sloping line.

-   The regression line has a clear positive slope meaning that BFP changes as BMI increases

-   This indicates a strong correlation between BMI and BFP.

### Pearson’s correlation coefficient

When calculation the correlation coefficient the following values determine the correlation

Value close to 1 = strong positive correlation.

Value close to -1 = strong negative correlation.

Value close to 0 = no linear correlation.

The variable that is closest to ±1 correlates more strongly with BMI.

```{r}
#To calculate the correlation, the build in R function cor() is used
Cor_coef_BMI_WHR <- cor(diabetes_data$BMI, diabetes_data$WHR, use = "complete.obs")
Cor_coef_BMI_BFP <- cor(diabetes_data$BMI, diabetes_data$BFP, use = "complete.obs")

#displaying the results
cat("Correlation between BMI and WHR:", Cor_coef_BMI_WHR, "\n")
cat("Correlation between BMI and BFP:", Cor_coef_BMI_BFP, "\n")
```

**As can be seen from the calculated correlation coefficients, BFP correlates better with BMI than WHR as the correlation coefficient is closest to 1, showing a strong positive correlation.**

## **Q19: How many women and men are there in the data set?**

```{r}
diabetes_data %>%
  count(gender)
```

There are 234 females and 169 men in the data set

## **Q20: How many women and men are there from Buckingham and Louisa respectively in the data set?**

```{r}
diabetes_data %>%
  count(location, gender)
```

From Buckingham there are 114 females and 86 males

From Louisa there are 120 females and 83 males

## **Q21: How many are in each of the `BMI_class` groups?**

```{r}
diabetes_data %>%
  count(BMI_class)
```

## **Q22: Given the code below, explain the difference between A and B?**

**code A:**

```{r}
# A
diabetes_data |>
  ggplot(aes(x = BMI_class)) +
  geom_bar()
```

Here, geom_bar() counts the rows automatically (stat = "count").

You only give it x = BMI_class, and ggplot does the counting for you behind the scenes.

It produces a bar chart with bar heights = number of rows in each BMI_class.

**Code B:**

```{r}
# B
diabetes_data |>
  count(BMI_class) |>
  ggplot(aes(x = BMI_class, y = n)) +
  geom_col()

```

Here, you first explicitly count how many rows are in each BMI_class using count().

That gives you a dataset with two columns: BMI_class and n.

Then you use geom_col(), which takes the values in n as the bar heights (no internal counting).

**Difference between A and B**

A (geom_bar): ggplot does the counting automatically.

B (geom_col): you do the counting manually with count(), then pass the results to ggplot.

## **T9: For each `BMI_class` group, calculate the average weight and associated standard deviation**

```{r}
diabetes_data %>%
  #goup by BMI class
  group_by(BMI_class) %>%
  
  #calculate the mean weight and standard deviation
  summarise(
    avg_weight = mean(weight, na.rm = TRUE),
    sd_weight  = sd(weight, na.rm = TRUE),
    .groups = "drop"
  )
```

## **Q23: What was the average age of the women living in Buckingham in the study?**

```{r}
diabetes_data %>%
  #filter for female and location of Buckingham
  filter(gender == "female", location == "Buckingham") %>%
  
  #calculate the mean age
  summarise(avg_age = mean(age, na.rm = TRUE))
```

The average age of women living in Buckingham is 46.5 years
